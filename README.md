# Task_for_LestaStudio
---
## Задание №1

**Условие:**
> На языке Python реализовать алгоритм (функцию) определения четности целого числа, который будет аналогичен нижеприведенному по функциональности, но отличен по своей сути. Объяснить плюсы и минусы обеих реализаций.

1. Исходный код [ссылка](https://github.com/Solidbush/Task_for_LestaStudio/blob/master/Task_1_isEven/main.py)

Вариант 1
```python
Python example:
def isEven(value):return value%2==0
```

Вариант 2
```python
def is_Even(value):
    return value & 1 == 0
```

[+] Из плюсов первого решения можно отметить, что это то решение, которое первым приходит на ум в задачах про четность.

[-] Однако немного полистав статьи на Хабр, можно предположить, что побитовые операции выполняются некоторыми компиляторами намного быстрее, чем `value%2==0`, что является плюсом второго решения.

---

## Задание №2
**Условие**
>На языке Python (2.7) реализовать минимум по 2 класса реализовывающих циклический буфер FIFO. Объяснить плюсы и минусы каждой реализации.

1. Исходный код [ссылка](https://github.com/Solidbush/Task_for_LestaStudio/tree/master/Task_2_FIFO)

В этом задании я представил два варианта реализации циклического буфера FIFO:
+ С помошью указателей на элементы по индексу
+ С помощью циклического сдвига списка

Оба варианта являются практически идентичными решениями, однако в первом не используются встроенные методы такие, как `pop`, `append` и т.д.

[+] К плюсом первой реализации можно отнести удаление и добавление элемента за О(1), так как используются указатели на первый и последний элементы.

[-] Из минусов можно отметить, что используются логические операции для продвижения указателей при их совпадении.

[+] Плюсом второй реализации является более понятный и лаканичный код, так как нет такого количества логических операци.

[-] Но а из минусов можно отметить использование встроенных методов.

Могу добавить, что на первом курсе я выполнял похожее задание, но на языка С++. 
В самом буфере я не использовал стандартные STL контейнеры, а применял итераторы произвольного доступа (Random access iterators).
проект: [ссылка](https://github.com/Solidbush/Programming-labs-second-term/tree/master/Curcle_Buffer)

---

## Задание №3
**Условие**
>На языке Python реализовать функцию, которая быстрее всего (по процессорным тикам) отсортирует данный ей массив чисел. Массив может быть любого размера со случайным порядком чисел (в том числе и отсортированным). Объяснить почему вы считаете, что функция соответствует заданным критериям.

1. Исходный код [ссылка](https://github.com/Solidbush/Task_for_LestaStudio/blob/master/Task_3_HeapSort/main.py)

Для решения это задачи я представил реализацию `Heapsort` или «Сортировку кучей», я выбрал этот  алгоритм сортировки, так как он работае в худшем, в среднем и в лучшем случае (то есть гарантированно) за  O(nlog n) операций при сортировке n элементов, а также количество применяемой служебной памяти не зависит от размера массива (то есть, O(1)).

Из минусов данной сортировки можно отмететь, то что она не устойчивая и на отсортированных масивах работает также долго, как и на неотсортированных.
Однако, в задании сказано про возможность наличия таких, а устойчивость в сделку не входила :)

Также я рассматривал вариант реализации сортировки Хоара, но подсчитал, что O(n) дополнительной памяти и возможность попадания в средний случай O(n) из-за почти отсортированных массивов намного хуже, чем гарантированное О(nlog n)

---

### Задание выполнил [Гаврилов Алексей](https://github.com/Solidbush)